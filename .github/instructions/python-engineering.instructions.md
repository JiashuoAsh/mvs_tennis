---
applyTo: "**/*.py"
---

# Python 工程化重构规范（通用）

触发条件（满足任一条就按“诊断->计划->实施->自检”流程）：
- 单模块混合多类职责：业务/算法 + IO/硬件/网络 + 入口/配置
- 高耦合：改一处经常牵扯多处无关代码
- scripts 被当库 import、或存在循环依赖风险
- 功能无法通过稳定 API 供其他程序复用（只能复制/深层 import）

目标形态（推荐，视项目规模与稳定性选用）：
- core：纯业务/算法（尽量不依赖硬件/网络/文件系统/CLI；必要时通过参数/回调注入）
- adapters：IO/硬件/SDK/文件读写（薄层）
- entry：cli/apps/scripts（参数解析与组装依赖，只调用 core）

硬性验收：
- 依赖方向：adapters/entry -> core；core 不得反向依赖 adapters/entry
- 对外 API 收敛：少量入口函数/类；内部细节私有化（_ 前缀）
- 中文：注释/log/docstring 用中文
- 可验证：必须提供可复现的验证闭环。
	- 小改动：至少 happy path（import 冒烟/最小单测/最小运行路径三选一）。
	- 大改动或破坏式变更：必须补充更强验证（优先跑全量测试；若无测试框架，至少提供 happy path + 关键边界/异常之一，并写明如何复现）。

限制：
- 依赖策略：优先使用标准库；当引入成熟依赖能显著降低复杂度/缺陷概率或提升可维护性时，建议引入。
	- 引入时必须说明必要性与替代方案，并同步更新依赖声明（如 pyproject.toml/锁文件）与最小验证。
- 不引入复杂抽象：只有当确实存在 ≥2 种实现需要替换时才考虑接口/ABC
