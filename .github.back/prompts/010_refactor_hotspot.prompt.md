---
name: 010_refactor_hotspot
description: "重构热点：先定位->诊断->计划->小步实施->自检（破坏式可选，默认清零旧路径）"
argument-hint: "hotspot=路径或描述；breaking=1/0；scope=可选"
agent: "agent"
---

输入：
- 热点（路径或描述）：${input:hotspot:可填文件/目录路径；也可填一段问题描述，如“utils.py 太大且多处被import，想拆分并清零旧路径”}
- 是否允许破坏式变更：${input:breaking:1=允许修改对外API并清零旧路径；0=保持对外API兼容（默认1）}
- 搜索范围（可选）：${input:scope:留空=全仓库；也可填目录前缀如 libs/、steps/、src/}

全局约束：
- 禁止臆测：所有结论必须引用仓库证据（路径/符号/README/pyproject/测试）。
- 避免不必要的新增第三方依赖（确需新增时允许）：必须说明必要性/替代方案/影响面，并同步更新依赖声明（如 pyproject.toml/锁文件）与最小验证；不上复杂架构/插件系统。
- 注释/log/docstring 用中文。

当 breaking=1（破坏式）时：
- 允许修改模块结构与对外 API
- 禁止保留 wrapper/兼容层/旧模块转发
- 必须同步更新仓库内所有调用点，确保旧路径/旧符号清零（给出搜索关键字与清零结果）

当 breaking=0（兼容式）时：
- 对外 import 路径/符号/签名保持不变
- 允许内部迁移实现，但必须保留薄兼容层（仅转发，不含业务逻辑）

要求你按固定流程输出并执行（不要跳步）：

A) 定位与诊断（只读分析）
如果 hotspot 是“描述”而不是“路径”，先做定位：
1) 候选列表：列出 3-5 个最可能的文件/目录（路径）并说明理由（引用证据：grep/导入关系/README 提及等）
2) 锁定目标：选择 1 个主目标 + 可选 1-2 个伴随文件（说明为什么）
如果 hotspot 已是路径，则直接进入诊断：
- 这个热点承担哪些职责？（列点）
- 主要依赖点/调用方在哪里？（路径 + 关键符号）
- 当前结构问题属于：大文件/高耦合/目录放错/脚本被当库/入口混入库 等哪几类？

B) 计划（可执行迁移方案）
- 拟拆成哪些模块/目录（给出新路径清单）
- 每个模块一句话职责
- 依赖方向：IO/SDK/入口 -> core；core 不得依赖 IO/SDK/入口
- 对外 public API：少量入口函数/类（推荐 import 路径）
- 给出“全库修引用清单”：要改哪些 import/路径引用（提供可搜索关键字/正则，写清旧->新）

C) 小步实施（修改代码/移动文件）
- 一次只做一件事，确保每步改完都可 import/可运行
- 移动/重命名文件后必须同步修复 imports、入口调用方式、配置路径引用（若受影响）
- 避免不必要的新增第三方依赖（确需新增时允许）：必须说明必要性/替代方案/影响面，并同步更新依赖声明（如 pyproject.toml/锁文件）与最小验证；不上复杂架构/插件系统

D) 自检（必须给出）
- 至少提供一种最小验证方式：import 冒烟 +（若有入口）入口 --help +（若有测试）最小测试（happy path）
- 若仓库已有测试框架则用现有框架；没有则提供轻量自检函数/脚本示例
- breaking=1 时必须做“清零检查”：全库搜索旧路径/旧符号为 0（列出关键字与结果）

输出约束：
- 引用具体路径与符号名；找不到就写“未在仓库中找到”，并说明查找位置
